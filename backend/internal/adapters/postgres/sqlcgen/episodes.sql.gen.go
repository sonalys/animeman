// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: episodes.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	shared "github.com/sonalys/animeman/internal/domain/shared"
)

const createEpisode = `-- name: CreateEpisode :one
INSERT INTO episodes (
    id, season_id, media_id, type, number, titles, airing_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, season_id, media_id, type, number, titles, airing_date
`

type CreateEpisodeParams struct {
	ID         shared.ID
	SeasonID   shared.ID
	MediaID    shared.ID
	Type       MediaType
	Number     string
	Titles     []byte
	AiringDate pgtype.Timestamptz
}

func (q *Queries) CreateEpisode(ctx context.Context, arg CreateEpisodeParams) (Episode, error) {
	row := q.db.QueryRow(ctx, createEpisode,
		arg.ID,
		arg.SeasonID,
		arg.MediaID,
		arg.Type,
		arg.Number,
		arg.Titles,
		arg.AiringDate,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.MediaID,
		&i.Type,
		&i.Number,
		&i.Titles,
		&i.AiringDate,
	)
	return i, err
}

const deleteEpisode = `-- name: DeleteEpisode :exec
DELETE FROM episodes WHERE id = $1
`

func (q *Queries) DeleteEpisode(ctx context.Context, id shared.ID) error {
	_, err := q.db.Exec(ctx, deleteEpisode, id)
	return err
}

const getEpisode = `-- name: GetEpisode :one
SELECT id, season_id, media_id, type, number, titles, airing_date FROM episodes 
WHERE id = $1 LIMIT 1 FOR UPDATE
`

func (q *Queries) GetEpisode(ctx context.Context, id shared.ID) (Episode, error) {
	row := q.db.QueryRow(ctx, getEpisode, id)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.MediaID,
		&i.Type,
		&i.Number,
		&i.Titles,
		&i.AiringDate,
	)
	return i, err
}

const getEpisodeByNumber = `-- name: GetEpisodeByNumber :one
SELECT id, season_id, media_id, type, number, titles, airing_date FROM episodes 
WHERE season_id = $1 AND number = $2 LIMIT 1
`

type GetEpisodeByNumberParams struct {
	SeasonID shared.ID
	Number   string
}

// Useful for identifying a specific episode file during a disk scan
func (q *Queries) GetEpisodeByNumber(ctx context.Context, arg GetEpisodeByNumberParams) (Episode, error) {
	row := q.db.QueryRow(ctx, getEpisodeByNumber, arg.SeasonID, arg.Number)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.MediaID,
		&i.Type,
		&i.Number,
		&i.Titles,
		&i.AiringDate,
	)
	return i, err
}

const listEpisodesBySeason = `-- name: ListEpisodesBySeason :many
SELECT id, season_id, media_id, type, number, titles, airing_date FROM episodes 
WHERE season_id = $1 
ORDER BY airing_date ASC
`

func (q *Queries) ListEpisodesBySeason(ctx context.Context, seasonID shared.ID) ([]Episode, error) {
	rows, err := q.db.Query(ctx, listEpisodesBySeason, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Episode
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.SeasonID,
			&i.MediaID,
			&i.Type,
			&i.Number,
			&i.Titles,
			&i.AiringDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEpisodeMetadata = `-- name: UpdateEpisodeMetadata :one
UPDATE episodes
SET 
    type = $2,
    titles = $3,
    airing_date = $4
WHERE id = $1
RETURNING id, season_id, media_id, type, number, titles, airing_date
`

type UpdateEpisodeMetadataParams struct {
	ID         shared.ID
	Type       MediaType
	Titles     []byte
	AiringDate pgtype.Timestamptz
}

func (q *Queries) UpdateEpisodeMetadata(ctx context.Context, arg UpdateEpisodeMetadataParams) (Episode, error) {
	row := q.db.QueryRow(ctx, updateEpisodeMetadata,
		arg.ID,
		arg.Type,
		arg.Titles,
		arg.AiringDate,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeasonID,
		&i.MediaID,
		&i.Type,
		&i.Number,
		&i.Titles,
		&i.AiringDate,
	)
	return i, err
}
