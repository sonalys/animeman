// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: media.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/sonalys/animeman/internal/adapters/postgres/dtos"
	shared "github.com/sonalys/animeman/internal/domain/shared"
)

const createMedia = `-- name: CreateMedia :one
INSERT INTO media (
    id, collection_id, quality_profile_id, titles, 
    monitoring_status, monitored_since, genres, 
    airing_started_at, airing_ended_at, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, collection_id, quality_profile_id, titles, monitoring_status, monitored_since, genres, airing_started_at, airing_ended_at, created_at, titles_search_vector
`

type CreateMediaParams struct {
	ID               shared.ID
	CollectionID     shared.ID
	QualityProfileID shared.ID
	Titles           dtos.Titles
	MonitoringStatus MonitoringStatus
	MonitoredSince   pgtype.Timestamptz
	Genres           []string
	AiringStartedAt  pgtype.Timestamptz
	AiringEndedAt    pgtype.Timestamptz
	CreatedAt        pgtype.Timestamptz
}

func (q *Queries) CreateMedia(ctx context.Context, arg CreateMediaParams) (Medium, error) {
	row := q.db.QueryRow(ctx, createMedia,
		arg.ID,
		arg.CollectionID,
		arg.QualityProfileID,
		arg.Titles,
		arg.MonitoringStatus,
		arg.MonitoredSince,
		arg.Genres,
		arg.AiringStartedAt,
		arg.AiringEndedAt,
		arg.CreatedAt,
	)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.CollectionID,
		&i.QualityProfileID,
		&i.Titles,
		&i.MonitoringStatus,
		&i.MonitoredSince,
		&i.Genres,
		&i.AiringStartedAt,
		&i.AiringEndedAt,
		&i.CreatedAt,
		&i.TitlesSearchVector,
	)
	return i, err
}

const deleteMedia = `-- name: DeleteMedia :exec
DELETE FROM media WHERE id = $1
`

func (q *Queries) DeleteMedia(ctx context.Context, id shared.ID) error {
	_, err := q.db.Exec(ctx, deleteMedia, id)
	return err
}

const findMediaByExactTitle = `-- name: FindMediaByExactTitle :many
SELECT id, collection_id, quality_profile_id, titles, monitoring_status, monitored_since, genres, airing_started_at, airing_ended_at, created_at, titles_search_vector FROM media
WHERE titles @> jsonb_build_array(jsonb_build_object('Value', $1::text))
`

// Uses the GIN index on the titles JSONB for an exact match within the array
func (q *Queries) FindMediaByExactTitle(ctx context.Context, dollar_1 string) ([]Medium, error) {
	rows, err := q.db.Query(ctx, findMediaByExactTitle, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.QualityProfileID,
			&i.Titles,
			&i.MonitoringStatus,
			&i.MonitoredSince,
			&i.Genres,
			&i.AiringStartedAt,
			&i.AiringEndedAt,
			&i.CreatedAt,
			&i.TitlesSearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMedia = `-- name: GetMedia :one
SELECT id, collection_id, quality_profile_id, titles, monitoring_status, monitored_since, genres, airing_started_at, airing_ended_at, created_at, titles_search_vector FROM media WHERE id = $1 LIMIT 1 FOR UPDATE
`

func (q *Queries) GetMedia(ctx context.Context, id shared.ID) (Medium, error) {
	row := q.db.QueryRow(ctx, getMedia, id)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.CollectionID,
		&i.QualityProfileID,
		&i.Titles,
		&i.MonitoringStatus,
		&i.MonitoredSince,
		&i.Genres,
		&i.AiringStartedAt,
		&i.AiringEndedAt,
		&i.CreatedAt,
		&i.TitlesSearchVector,
	)
	return i, err
}

const listMediaPaginated = `-- name: ListMediaPaginated :many
SELECT id, collection_id, quality_profile_id, titles, monitoring_status, monitored_since, genres, airing_started_at, airing_ended_at, created_at, titles_search_vector FROM media
WHERE 
    id < $3::uuid AND
    collection_id = $2
ORDER BY id DESC
LIMIT $1
`

type ListMediaPaginatedParams struct {
	Limit        int32
	CollectionID shared.ID
	LastID       shared.ID
}

func (q *Queries) ListMediaPaginated(ctx context.Context, arg ListMediaPaginatedParams) ([]Medium, error) {
	rows, err := q.db.Query(ctx, listMediaPaginated, arg.Limit, arg.CollectionID, arg.LastID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.QualityProfileID,
			&i.Titles,
			&i.MonitoringStatus,
			&i.MonitoredSince,
			&i.Genres,
			&i.AiringStartedAt,
			&i.AiringEndedAt,
			&i.CreatedAt,
			&i.TitlesSearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMediaByTitlePaginated = `-- name: SearchMediaByTitlePaginated :many
SELECT id, collection_id, quality_profile_id, titles, monitoring_status, monitored_since, genres, airing_started_at, airing_ended_at, created_at, titles_search_vector, similarity(titles_search_vector, $1) as score
FROM media
WHERE titles_search_vector % $1
AND (similarity(titles_search_vector, $1), id) < ($2::float4, $3::uuid)
ORDER BY score DESC, id ASC
LIMIT $4
`

type SearchMediaByTitlePaginatedParams struct {
	Similarity string
	Column2    float32
	Column3    shared.ID
	Limit      int32
}

type SearchMediaByTitlePaginatedRow struct {
	ID                 shared.ID
	CollectionID       shared.ID
	QualityProfileID   shared.ID
	Titles             dtos.Titles
	MonitoringStatus   MonitoringStatus
	MonitoredSince     pgtype.Timestamptz
	Genres             []string
	AiringStartedAt    pgtype.Timestamptz
	AiringEndedAt      pgtype.Timestamptz
	CreatedAt          pgtype.Timestamptz
	TitlesSearchVector pgtype.Text
	Score              float32
}

// Paginates fuzzy search results based on the last seen score and ID
func (q *Queries) SearchMediaByTitlePaginated(ctx context.Context, arg SearchMediaByTitlePaginatedParams) ([]SearchMediaByTitlePaginatedRow, error) {
	rows, err := q.db.Query(ctx, searchMediaByTitlePaginated,
		arg.Similarity,
		arg.Column2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchMediaByTitlePaginatedRow
	for rows.Next() {
		var i SearchMediaByTitlePaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.QualityProfileID,
			&i.Titles,
			&i.MonitoringStatus,
			&i.MonitoredSince,
			&i.Genres,
			&i.AiringStartedAt,
			&i.AiringEndedAt,
			&i.CreatedAt,
			&i.TitlesSearchVector,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMedia = `-- name: UpdateMedia :exec
UPDATE media
SET 
    titles = $2,
    monitoring_status = $3, 
    monitored_since = $4,
    genres = $5,
    airing_started_at = $6,
    airing_ended_at = $7,
    quality_profile_id = $8
WHERE id = $1
`

type UpdateMediaParams struct {
	ID               shared.ID
	Titles           dtos.Titles
	MonitoringStatus MonitoringStatus
	MonitoredSince   pgtype.Timestamptz
	Genres           []string
	AiringStartedAt  pgtype.Timestamptz
	AiringEndedAt    pgtype.Timestamptz
	QualityProfileID shared.ID
}

func (q *Queries) UpdateMedia(ctx context.Context, arg UpdateMediaParams) error {
	_, err := q.db.Exec(ctx, updateMedia,
		arg.ID,
		arg.Titles,
		arg.MonitoringStatus,
		arg.MonitoredSince,
		arg.Genres,
		arg.AiringStartedAt,
		arg.AiringEndedAt,
		arg.QualityProfileID,
	)
	return err
}

const updateMediaQualityProfile = `-- name: UpdateMediaQualityProfile :exec
UPDATE media
SET quality_profile_id = $2
WHERE id = $1
`

type UpdateMediaQualityProfileParams struct {
	ID               shared.ID
	QualityProfileID shared.ID
}

func (q *Queries) UpdateMediaQualityProfile(ctx context.Context, arg UpdateMediaQualityProfileParams) error {
	_, err := q.db.Exec(ctx, updateMediaQualityProfile, arg.ID, arg.QualityProfileID)
	return err
}
