// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: collections.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	shared "github.com/sonalys/animeman/internal/domain/shared"
)

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (
    id, owner_id, name, base_path, tags, monitored, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, owner_id, name, base_path, tags, monitored, created_at
`

type CreateCollectionParams struct {
	ID        shared.ID
	OwnerID   shared.ID
	Name      string
	BasePath  string
	Tags      []string
	Monitored bool
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, createCollection,
		arg.ID,
		arg.OwnerID,
		arg.Name,
		arg.BasePath,
		arg.Tags,
		arg.Monitored,
		arg.CreatedAt,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.BasePath,
		&i.Tags,
		&i.Monitored,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections
WHERE id = $1
`

func (q *Queries) DeleteCollection(ctx context.Context, id shared.ID) error {
	_, err := q.db.Exec(ctx, deleteCollection, id)
	return err
}

const findCollectionsByTag = `-- name: FindCollectionsByTag :many
SELECT id, owner_id, name, base_path, tags, monitored, created_at FROM collections
WHERE $1 = ANY(tags) AND owner_id = $2
`

type FindCollectionsByTagParams struct {
	Tags    []string
	OwnerID shared.ID
}

// Uses the GIN index to find collections containing the specified tag
func (q *Queries) FindCollectionsByTag(ctx context.Context, arg FindCollectionsByTagParams) ([]Collection, error) {
	rows, err := q.db.Query(ctx, findCollectionsByTag, arg.Tags, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.BasePath,
			&i.Tags,
			&i.Monitored,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollection = `-- name: GetCollection :one
SELECT id, owner_id, name, base_path, tags, monitored, created_at FROM collections
WHERE id = $1 LIMIT 1 FOR UPDATE
`

func (q *Queries) GetCollection(ctx context.Context, id shared.ID) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollection, id)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.BasePath,
		&i.Tags,
		&i.Monitored,
		&i.CreatedAt,
	)
	return i, err
}

const listCollectionsByOwner = `-- name: ListCollectionsByOwner :many
SELECT id, owner_id, name, base_path, tags, monitored, created_at FROM collections
WHERE owner_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCollectionsByOwner(ctx context.Context, ownerID shared.ID) ([]Collection, error) {
	rows, err := q.db.Query(ctx, listCollectionsByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.BasePath,
			&i.Tags,
			&i.Monitored,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setMonitoredStatus = `-- name: SetMonitoredStatus :exec
UPDATE collections
SET monitored = $2
WHERE id = $1
`

type SetMonitoredStatusParams struct {
	ID        shared.ID
	Monitored bool
}

// Useful for bulk actions in the UI
func (q *Queries) SetMonitoredStatus(ctx context.Context, arg SetMonitoredStatusParams) error {
	_, err := q.db.Exec(ctx, setMonitoredStatus, arg.ID, arg.Monitored)
	return err
}

const updateCollection = `-- name: UpdateCollection :one
UPDATE collections
SET 
    name = $2,
    base_path = $3,
    tags = $4,
    monitored = $5
WHERE id = $1
RETURNING id, owner_id, name, base_path, tags, monitored, created_at
`

type UpdateCollectionParams struct {
	ID        shared.ID
	Name      string
	BasePath  string
	Tags      []string
	Monitored bool
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, updateCollection,
		arg.ID,
		arg.Name,
		arg.BasePath,
		arg.Tags,
		arg.Monitored,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.BasePath,
		&i.Tags,
		&i.Monitored,
		&i.CreatedAt,
	)
	return i, err
}

const updateCollectionTags = `-- name: UpdateCollectionTags :exec
UPDATE collections
SET tags = $2
WHERE id = $1
`

type UpdateCollectionTagsParams struct {
	ID   shared.ID
	Tags []string
}

func (q *Queries) UpdateCollectionTags(ctx context.Context, arg UpdateCollectionTagsParams) error {
	_, err := q.db.Exec(ctx, updateCollectionTags, arg.ID, arg.Tags)
	return err
}
