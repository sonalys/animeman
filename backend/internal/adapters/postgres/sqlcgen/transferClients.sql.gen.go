// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transferClients.sql

package sqlcgen

import (
	"context"
)

const createTransferClient = `-- name: CreateTransferClient :one
INSERT INTO transfer_clients (
    id, owner_id, address, type, auth_id
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, owner_id, address, type, auth_id
`

type CreateTransferClientParams struct {
	ID      string
	OwnerID string
	Address string
	Type    TransferClientType
	AuthID  string
}

func (q *Queries) CreateTransferClient(ctx context.Context, arg CreateTransferClientParams) (TransferClient, error) {
	row := q.db.QueryRow(ctx, createTransferClient,
		arg.ID,
		arg.OwnerID,
		arg.Address,
		arg.Type,
		arg.AuthID,
	)
	var i TransferClient
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Address,
		&i.Type,
		&i.AuthID,
	)
	return i, err
}

const deleteTransferClient = `-- name: DeleteTransferClient :exec
DELETE FROM transfer_clients
WHERE id = $1
`

// Cascade will handle the associated row in authentications
func (q *Queries) DeleteTransferClient(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteTransferClient, id)
	return err
}

const getTransferClient = `-- name: GetTransferClient :one
SELECT 
    tc.id, tc.owner_id, tc.address, tc.type,
    a.id as auth_id, a.type as auth_type, a.credentials as auth_credentials
FROM transfer_clients tc
JOIN authentications a ON tc.auth_id = a.id
WHERE tc.id = $1 LIMIT 1 FOR UPDATE
`

type GetTransferClientRow struct {
	ID              string
	OwnerID         string
	Address         string
	Type            TransferClientType
	AuthID          string
	AuthType        AuthType
	AuthCredentials []byte
}

// Reconstructs the TransferClient aggregate with nested Authentication
func (q *Queries) GetTransferClient(ctx context.Context, id string) (GetTransferClientRow, error) {
	row := q.db.QueryRow(ctx, getTransferClient, id)
	var i GetTransferClientRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Address,
		&i.Type,
		&i.AuthID,
		&i.AuthType,
		&i.AuthCredentials,
	)
	return i, err
}

const listTransferClientsByOwner = `-- name: ListTransferClientsByOwner :many
SELECT 
    tc.id, tc.owner_id, tc.address, tc.type,
    a.id as auth_id, a.type as auth_type, a.credentials as auth_credentials
FROM transfer_clients tc
JOIN authentications a ON tc.auth_id = a.id
WHERE tc.owner_id = $1
ORDER BY tc.id
`

type ListTransferClientsByOwnerRow struct {
	ID              string
	OwnerID         string
	Address         string
	Type            TransferClientType
	AuthID          string
	AuthType        AuthType
	AuthCredentials []byte
}

func (q *Queries) ListTransferClientsByOwner(ctx context.Context, ownerID string) ([]ListTransferClientsByOwnerRow, error) {
	rows, err := q.db.Query(ctx, listTransferClientsByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTransferClientsByOwnerRow
	for rows.Next() {
		var i ListTransferClientsByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Address,
			&i.Type,
			&i.AuthID,
			&i.AuthType,
			&i.AuthCredentials,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransferClientAddress = `-- name: UpdateTransferClientAddress :exec
UPDATE transfer_clients
SET address = $2
WHERE id = $1
`

type UpdateTransferClientAddressParams struct {
	ID      string
	Address string
}

func (q *Queries) UpdateTransferClientAddress(ctx context.Context, arg UpdateTransferClientAddressParams) error {
	_, err := q.db.Exec(ctx, updateTransferClientAddress, arg.ID, arg.Address)
	return err
}
